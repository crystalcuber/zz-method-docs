---
title: Method Development Life Cycle
description: Metohd development guide for Rubik's Cube and other puzzles.
author: James Straughan
---

import Image from "next/image";

<Image
  src="/assets/MethodDev/MethodDevelopmentLifeCycle.png"
  alt="Method Development Life Cycle"
  width={400}
  height={428}
/>

## Introduction

Method development is the design of a method that solves a puzzle while adhering to human limitations or other goals. If humans were able to memorize algorithms for all 43 quintillion states, immediately recall the algorithm associated with the current scramble, and quickly execute the algorithm, there would be no need to design methods for speedsolving. Because we are imperfect, we have to find ways of solving that fit our abilities and our limitations.

Method development can often feel like trying to develop a perpetual motion machine. There is always a balance that occurs. Move count, ergonomics, recognition, and other aspects have their own tradeoffs. Reducing the move count of a method can come at the cost of a higher number of algorithms or difficulty in thinking quickly enough to apply a particular technique. A focus on ergonomics may increase the overall move count. Achieving the right balance, as well as finding a unique set of steps, is what constitutes the art of method development.

How can you create your own quality method? Currently there isn't a definitive list of steps to follow that will guarantee the development of a good method. Being able to create something that is both original and speedsolving capable comes with a lot of experience. It is likely that the first ideas you have will already exist and have probably been considered by many other people. Or, your first method may contain disadvantages that outweigh its advantages. Even getting really fast with a method and relying on that experience wouldn't provide the knowledge of what makes up a good method. Speedsolving skills can potentially provide some of the nuances of algorithm quality kowledge, look ahead, and other traits. But it takes actual development experience and or studying various methods to be able to incorporate all aspects of development to create a quality method.

In an attempt to help you be successful, a guide is provided in the form of a method development life cycle. This guide will step you through the process of finding an original idea, developing the idea into a method, and promoting and maintaining the method to ensure that it remains up to date. With enough practice designing methods, you should be able to develop an intuition for problem solving and the ability to filter out bad ideas.

## Ideation

Every method starts with an idea. The idea can be a method that has a specific shape, to create a certain style of method, or to solve an existing problem. How do you think of a new idea? The best place to start is by looking at existing methods. Maybe a new method shape can be derived from one of them. Or maybe one of the methods has a flaw that can be removed by reworking the steps of the method. Sometimes, but very rarely, randomly combining two methods together can lead to something new. Often the result of these combinations is a method that is less than the sum of its parts. But from this basic idea it may be possible to refine the method into something more viable.

In the beginning it will be easiest to think of a new method shape idea and base your method around that. But when trying to create a method that is genuinely new and competitive, try not to let that be your focus. Most of the possible method shapes and their continuations to the end of the solve have been almost completely explored. Almost every method is simply another order of solving 12 edges, eight corners, and six centers. Thom Barlow, the developer of the K4 method among other developments, once said “The state of method development at the moment is such that any sufficiently thought-out method of the form of solving groups of permutation and orientation in a variety of ways can perform as well as its brethren with minor positives and negatives depending on changes, until something more abstract comes out.”

If you want to create something that is truly unique or has a higher chance of being a better method than the methods that are currently perceived to be top methods, more has to be done than just solving the various pieces in a different order. Try to solve a major problem in a method or method development itself, or create a new concept. As an example, the method named “42” uses conjugation to produce a method that has a very low move count and close to 15 times fewer required algorithms to memorize than if the technique wasn't used. There is also the method named “CEOR” that permutes all of the corners into a specific orbit at the start of the solve. This sets up the cube to be able to be solved using turns of just the upper layer, the right-side layer, and the middle layer adjacent to it. The result is a method that is comfortable for one-handed solving use. New concepts such as these have the potential to change what everyone thought were the limits of speedsolving. To emphasize the importance of focusing on new concepts, Joseph Briggs, developer of the methods 42 and SSC, put a twist on one of Arthur C. Clarke's three laws by stating "Any method distinguishable from magic is insufficiently advanced."

Once the idea or goal is set, it is important to perform research. The idea may have already been developed or the problem that was identified may already have a solution. Be careful not to develop something that someone else has already put work into creating. Method duplication has occurred numerous times in the puzzle community due to the lack of thorough research before starting development. Research the various methods to determine if your idea has already been developed or mentioned by someone else. Below are some resources for researching methods.

- **[SpeedSolving.com](https://www.speedsolving.com/):** SpeedSolving.com has a dedicated Wiki containing a large selection of method pages. In addition, the website and forum was created in 2006 so there have been many discussions on method ideas. Most notably, [The New Method / Substep / Concept Idea Thread](https://www.speedsolving.com/threads/the-new-method-substep-concept-idea-thread.40975/) contains thousands of posts consisting of method ideas and discussions.
- **[Cubing History](https://www.cubinghistory.com/):** This website provides the history of various methods and techniques. You can use this resource not only to learn about the history of existing methods, but also to see the thought process behind the development of each method. Seeing how someone else formulated an idea and refined it into a successful method may help you develop your own thought processes.
- **Discord:** There are several servers on Discord dedicated to discussions on individual methods and methods in general. You can join these servers to discuss ideas to determine if they exist, receive feedback on an idea, or collaborate on development. Below are a couple of the most useful servers.
  - **[Method Development](https://discord.gg/xtZaubNkzg):** This is a dedicated method development server for all puzzles. Within the server, there is also a chennel that links to servers for many individual methods.
  - **[Straughan's Development Server](https://discord.gg/GJB2ER2Q3M):** A server focusing on the developments of James Straughan as well as general method development discussions.

A final note is that there are some commonly proposed methods that don't always contain their own pages on a wiki or other websites. Below are some commonly invented methods to be aware of.

- **Belt:** This may be the most re-invented method, outside of Corners First, Edges First, and Layer By Layer. The general steps are to solve the edges of the E layer then complete the rest of the cube.
- **RouxFOP:** When experimenting with Roux and CFOP, you may have the idea to combine the two methods. The steps would be to solve the two 1x2x3 blocks as in Roux, add the bottom layer edges, then orient and permute the last layer as in CFOP. This method is frequently suggested by those new to solving. The problem is that this combination method doesn't take advantage of the strengths of the Roux method, which are its low move count and ergonomics. It also doesn't have the same quality of look ahead for solving the first two layers as CFOP.
- **ZBRoux:** Taking RouxFOP further, you can combine Roux and ZZ. The idea here is to solve the two 1x2x3 blocks as in Roux, orient the last layer edges while solving the bottom layer edges, then solve the last layer using a single algorithm.
- **Non-EO Petrus:** Another common idea is to use the Petrus method's idea of continually blockbuilding as far as possible, but omitting or moving edge orientation to a later stage. The commonly proposed steps are to solve a 2x2x3 block, add a 1x2x2 block to the first two layers, solve the last corner and edge pair of the first two layers, then solve the last layer.

## Design

Once you have determined your idea or goal, it is time to plan the steps. In the Design phase, the various possibilities are considered and compared against each other. It isn't always the case that the first idea that comes to mind for the steps of a method will be the best one possible. Continue considering every possible step and variant. This will aid you in discovering the optimal variant for the method that you are designing. In addition to considering your own ideas, look to other methods to see if steps from those can be adapted. It may turn out that one or two steps of another method will be the best variant for your own method. Or maybe you will hit on a great new idea that hasn't yet been proposed or developed for any existing method.

If you are starting from a basic method shape, try to think of many possible continuations. Maybe you can start by solving the remaining corners then solve the last few edges in some way. Or you can complete the first two layers and have a layer to solve in the end. Or, possibly something more abstract will turn out to be the most natural fit for your starting shape and may also make for something unique. If instead you are focusing on solving a problem inherent with an existing method, determine exactly why it is a problem. Knowing why it is a flaw is the first step toward finding a solution. Maybe the solution will be to solve more pieces at once in a step, or to solve a couple of steps in a different order, or it may even be that the method needs to be completely deconstructed and rebuilt into something new. To use the APB method as an example, the idea was that the edge orientation step of the Petrus method is a bottleneck slowing progress of the solve. When trying to find a better continuation for the method, it was decided to reduce the number of edges involved in the orientation step and reduce blindspots by solving additional pieces along with the 2x2x3 block.

Try to find a balance to the number of algorithms and the move count. It is possible to design a method with an extremely low move count, but it may require the user to memorize and practice hundreds of algorithms. Methods such as these can turn out to be advanced and potentially useful in the future, but it is much more likely that the method will be of the same or lower quality than other methods while also requiring much more effort to use. Also try to avoid designing a method that could be viewed as derivative. There is nothing wrong with creating a new method that starts as just another way of solving the first two layers, for example. However, there are already existing ways of reaching that state that have been proven to be very effective. The chance is low that a different set of steps will measure up and it would be a very competitive space to attempt to occupy.

## Analysis

Coming from the Design phase you should have a variant or a method that you have worked out. Before starting development, it is essential to analyze every aspect of the method. You have to answer the basic question “Is my idea good?” Below are some things that are important to cover.

- Are the intuitive steps easy to perform? Low effort means less time spent practicing to become proficient and a better trajectory towards achieving fast solving times.
- Calculate the average move count of the method. A low move count isn't necessarily evidence that your method is of high quality, but a high move count has the potential to exclude a method from any high level conversations. For the currently popular methods, the move counts average around 45-55 moves. If your method contains some steps that exist in other methods, the average move count for those steps may already be known and available to use. For steps that are more unique where the move count isn't known, you can practice solving the method many times for intuitive steps to find an average move count or use algorithm generator programs for algorithm-based steps.
- Count the number of algorithms that the user of the method will be required to memorize. Compared to other methods, does your method contain more algorithms? If so, are there benefits to your method that make it worth it to learn the algorithms?
- Generate the algorithms for each step of your method. Test these algorithms to determine the ergonomics and length. Are the algorithms comfortable to perform? Do they have an acceptable move count average? If the algorithms aren't of high quality, that will have a major impact on the viability of the method.
- Test the recognition for each step. It is crucial that knowing what to do in each step is quick and easy to see. If a non-intuitive step takes a lot of time to recognize, that is additional time added to the solve.
- Ask the community for feedback. Others may have input that will help you either improve the method or help you realize that maybe the idea isn't as good as hoped or can be reworked.

During the analysis process, pay attention to the voice in your head that is telling you whether the idea is good or not. If the idea turns out to be not good, that answer can be difficult to accept. Especially if you developed an emotional attachment to the idea. But don't be afraid to throw an idea away. If it is unique and your absolute goal was to create something unique then that's ok. But if your goal is to create something that is competitive for speedsolving, either develop the idea with the caveat that it will only be intended as something fun to use or move on to a new idea. Or, try to go back to the Design phase and consider other possibilities. Keep drilling down until you can perfect a method.

## Development

Now that you have settled on a method that you have deemed worthy of being developed, the development process can be started. Development is the longest phase of the life cycle. Every aspect of the method is created and assembled into a finished product. Simply putting the idea out there often isn't enough. If the development phase is skipped, the idea risks becoming forgotten and later, rightfully so, credited to the proposer who independently had the idea and also put in the work to fully develop it.

The majority of development is often generating all of the algorithms for each of the non-intuitive steps and putting together the resources. There are several computer programs available for this process. Two of the most useful are CubeExplorer, which is useful for quickly generating individual cases with various move sets, and Batch Solver, which has the functionality of generating all of the algorithms at once for a step. During the algorithm generation process, place them into a document so that users have a reference from which to learn. Ensure that each algorithm is accompanied by images showing the case that the algorithm solves. Spreadsheet programs are most commonly used as a way to present algorithms. Alongside the algorithm generation process, decide on a way to recognize the cases for the step. That is, determine at which locations on the cube the user should look and what kinds of patterns reveal each case.

For the intuitive steps, develop strategies for efficiently solving them. Strategies have evolved a lot over time and there are many existing methods that you can look to for learning what works well. For any steps in your method that are already part of another method, it's likely that there are resources available. These can be referenced to shorten the development process or used as a basis upon which to build and add your own techniques.

A cube with good performance is also very useful in the Development phase. When you have a cube that has a good turning capability, it will allow for quick and easy testing of any algorithms that may be included in the method that is being developed.

When the method has been fully developed, decide on your form of presentation. To keep it simple, you can present links to the various documents covering the algorithms and techniques. Or, you can compile everything into a single document that describes the steps of the method and includes the algorithms. To take it a step further, you can create a website for the method and also film videos. These kinds of resources are attractive and project a sense of confidence in the method. Great resources are a major part in developing a community around a method.

There are many tools available for development. Below are some of the most useful.

- **[CubeExplorer](https://kociemba.org/cube.htm) and [Batch Solver](https://trangium.github.io/BatchSolver/):** These are two of the best tools for generating algorithms. CubeExplorer is a great program for quickly generating a single algorithm using a variety of move groups. Batch Solver is useful for generating a group of algorithms for a desired step. Batch Solver provides many features and there is a [video guide](https://www.youtube.com/watch?v=kSXFzK85Q8I) for its use created by Ryan Hudgens.
- **[Movecount Coefficient Calculator](https://trangium.github.io/MovecountCoefficient/):** A great program for testing algorithm quality. Input a list of algorithms and it will rank them according to their quality as performed by humans. It isn't perfect, but provides a good ranking of algorithms to aid in choosing the ones best for speedsolving.
- **Spreadsheet software:** Google Sheets is a popular way of presenting the algorithms for each step of a method.
- **[VisualCube](https://cube.rider.biz/visualcube.php):** Great for creating images. Images for the individual algorithms can be personally made if desired. However, VisualCube makes the process very easy. After an algorithm is input, the image is automatically generated. Individual stickers can be altered, arrows can be drawn, and many other features are included. It can even be combined with spreadsheet formulas to mass generate images for an entire list of algorithms.
- **[Twizzle.net](https://alpha.twizzle.net/edit/):** This website is useful for creating example solves to demonstrate the steps of a method. It can also be helfpful for visualizing the effects of a sequence of moves.
- **Algorithm databases and existing algorithm spreadsheets:** Databases such as [speedcubedb.com](https://speedcubedb.com/) can be used as a source if a step in the method is the same as that of another method. If the existing algorithms are good, they can be repurposed. If they aren't good, then it is best to re-generate the algorithms so that your method can be at its best.

## Publication

With development of the method completed, the next step is to put it out into the community. There are many ways that this can be done, including posting on message boards, social media groups, other social platforms, or a promotional video. Promotion is a major part of the development life cycle. It is what ensures that a method becomes known and spreads throughout the community. The more people who know about the method, the more who will try it out.

Be honest in your presentation and provide a list of advantages and disadvantages. Don't exaggerate the positives and downplay the negatives. It may be tempting to claim that your method contains incredible ergonomics, effortless recognition, and an extraordinarily low move count. But all of your positives should be backed up by evidence that should have been obtained in the Analysis and Development phases. There are programs available that can determine the optimal move count that a computer is able to achieve. Humans aren't as capable as these computer solutions. It is best to rely on general numbers that you or other people have been able to achieve in the past for the same or similar steps and also the actual numbers from the algorithm steps that you developed. Honesty in your presentation will greatly help you and your method's long-term reputation.

If the community thinks that the method has potential they will take notice. Sometimes it may take more time and effort to convince others of the advantages of a new method. Some methods contain new concepts or types of steps that are unfamiliar to others. Such new developments can initially be difficult to understand, so come prepared in your presentation. Think of the types of questions that everyone may ask and try to explain each step with the right balance of detail and simplicity. There aren't many methods that hold popularity and most people are focused on practicing solves and becoming fast with their already chosen method instead of paying attention to the latest developments. This means that, even with a decent amount of promotion effort, it may take time for a method to become well-known.

## Maintenance

Even after the method has been released to the public and has gone through the initial testing to be settled into its basic form, development isn't complete. Method development is an ongoing process and there is always more that can be done. Maintenance efforts continue the momentum of the method's growth in popularity and users.

Maintenance involves updating algorithms as better ones are found, adding any new viable advancements or variants, and generally improving upon any weak points. As new finger tricks are found, better puzzle hardware is introduced, and the number of users of the method grows, algorithm sets will change. New and better resources should also be created. It doesn't stop at the basic documents describing the method and listing the algorithms. Tutorials, whether written or in video form, will go a long way toward attracting new users. Maintenance isn't always left up to the creator of the method. With a large enough user base, maintaining the method becomes a community effort. Piece by piece the method is continually refined.

Inevitably the community will provide their opinion of the method. Be willing to listen to the critiques and update your method based on this feedback. People have experience in various areas of development or in solving. Their perspectives can help shape the method into something even better than you originally intended or considered. Other people can potentially give ideas for new and better variants, more ergonomic algorithms, and easier step recognition strategies. From the feedback that you receive, improve your method so that it has a better chance of gaining users. Continue this maintenance and hopefully your method will become popular.

## The Future of Methods

What's next for method development? Many speedsolving-oriented methods eventually merge one or more of its steps for efficiency, ergonomics, and other reasons. Additionally, methods tend to borrow techniques from other methods. CFOP users have integrated the blockbuilding and edge orientation techniques established by the Petrus method. Other methods have used and improved upon the more algorithm-based nature of CFOP. It is also interesting to consider that all modern speedsolving methods have a relatively similar average move count. The average move count is also over double that of what has been proven to be possible through computer analysis of scrambles. In practice and in competitions, solving has become a race to the bottom to execute 45 to 60 turns as quickly as possible.

With methods seemingly converging in several ways and the performance potential among them being similar, it may be time for a new line of thinking. Current methods largely follow a thought process of solving individual or groups of pieces step by step until the solved state is achieved. The final pieces to be solved sit around or within groups of already solved pieces. This means that turning movement is blocked and that the steps to solve the final pieces have to work within the restrictions caused by those previously solved pieces. In order to solve the final pieces, what was solved in previous steps must be broken to allow for freedom of movement for the unsolved pieces, then restored after solving those pieces. Solving in this way is like painting yourself into a corner, trekking across your work because you have no other choice, then fixing your mistakes afterward.

If a computer-generated solution to a scramble is examined, it appears to be a series of random turns until the cube is magically solved on the final turn. Yet, each turn is the result of a total awareness of every piece of the cube. All pieces are interconnected like a hive mind and are working together toward a common goal: the solved state. There may be revolutionary techniques that remain to be discovered. Or existing techniques that can be applied more broadly. The use of a new solving approach may preserve all of the important elements such as ergonomics, recognition, and look ahead, while bringing speedsolving closer to the mystifying move optimal solutions.
